# 浏览器 HTTP 缓存的分类

![HTTP 缓存](/img/httpCache.png)

浏览器 HTTP 缓存分两钟：

1. 强缓存
2. 协商缓存

**强缓存**指的是浏览器在本地判定缓存有无过期，未过期直接从内存或磁盘读取缓存，整个过程不需要和服务器通信。

**协商缓存**需要向服务器发送一次协商请求，请求时带上和协商缓存相关的请求头，由服务器判断缓存是否过期，未过期就返回状态码 304，浏览器当发现响应的返回码是 304，也直接是读取本地缓存，如果服务器判定过期就直接返回请求资源和 last-modified，状态码为 200。

### 强缓存和协商缓存的区别

1. 命中时状态码不同。强缓存返回 200，协商缓存返回 304。
2. 优先级不同。先判定强缓存，强缓存判断失败再判定协商缓存。
3. 强缓存的收益高于协商缓存，因为协商缓存相对于强缓存多了一次协商请求

## 强缓存

### Pragma

progma 是 HTTP1.0 时期的产物，和后面要说的 cache-control 作用差不多，它的值只能设置为 `no-cache`。与 Cache-Control: no-cache 效果一致，即禁用强缓存，只能使用协商缓存。

### Expires

有了Pragma来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对 HTTP1.0 而言，Expires 就是做这件事的首部字段。 Expires 的值对应一个GMT（格林尼治时间），比如`Mon, 22 Jul 2002 11:12:01 GMT`来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。

因为 expires 是一个时间值，如果服务器和客户端是系统时间差较大，就会引起缓存混乱。

### Cache-Control

HTTP 1.1 中增加的字段，被设计用来替代 pragma。cache-control 这个头部字段既可以用在请求头也可以用在响应头中。

### 优先级

**Pragma -> Cache-Control -> Expires** 。


| 头部                    | 可选值                                                       | 优先级 |
| :---------------------- | :----------------------------------------------------------- | :----- |
| Pragma(HTTP/1.0)        | no-cache:不直接使用缓存                                      | 高     |
| Cache-Control(HTTP/1.1) | 1. no-cache：不直接使用缓存   2. no-store:不直接使用缓存，每次都是下载最新资源  3.max-age：xx秒，缓存时常  4. public/private：是否只能被单个用户使用，默认为private  5. must-revalidate：每次访问需要缓存校验 | 中     |
| Expires(HTTP/1.0+)      | GMT 时间                                                     | 低     |

## 协商缓存

协商缓存中那几个首部字段是**配对使用**的，即：

- 请求头 if-modified-since 和响应头 last-modified
- 请求头 if-none-match 和响应头 etag

### Last-Modified

服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。

```
Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT
```

客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回`304`状态码，**内容为空**，这样就节省了传输数据量 。如果两个时间不一致，则服务器会发回该资源并返回`200`状态码，和第一次请求时类似。这样保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。一个`304`响应比一个静态资源通常小得多，这样就节省了网络带宽。

###  ETag

为了解决上述Last-Modified可能存在的不准确的问题，Http1.1还推出了 **ETag 实体首部**字段。 服务器会通过某种算法，给资源计算得出一个唯一标志符（比如md5标志），在把资源响应给客户端的时候，会在实体首部加上“ETag: 唯一标识符”一起返回给客户端。例如：

```js
Etag: "5d8c72a5edda8d6a:3239"
```

客户端会保留该 ETag 字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的ETag跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。
如果服务器发现ETag匹配不上，那么直接以常规GET `200`回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回`304`知会客户端直接使用本地缓存即可。
那么客户端是如何把标记在资源上的 ETag 传回给服务器的呢？请求报文中有两个首部字段可以带上 ETag 值：

#### 优先级

**if-none-match > if-modified-since**

当服务器收到的请求中同时包含 if-modified-since 和 if-none-match 时，服务器会忽略 if-modified-since。

| 头部                                       | 可选值                                                       | 优先级 | 优缺点                                                       |
| :----------------------------------------- | :----------------------------------------------------------- | :----- | ------------------------------------------------------------ |
| ETag/If-None-Match（HTTP/1.1）             | 校验值                                                       | 高     | 1. 默认使用 hash算法，分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时发现ETag不匹配的情况。2. 精确的判断资源有无被修改，可识别一秒内的修改次数 3. 计算 ETag 需要性能消耗 |
| Last-Modified/If-Modified-Sincel(HTTP/1.1) | 1. no-cache：不直接使用缓存   2. no-store:不直接使用缓存，每次都是下载最新资源  3.max-age：xx秒，缓存时常  4. public/private：是否只能被单个用户使用，默认为private  5. must-revalidate：每次访问需要缓存校验 | 低     | 1. 只要资源修改，无论内容有无变化，都会将资源返回客户端 2.以时刻为标识，无法获取一秒内的修改变化 3. 某些服务器不能准确获取最后修改时间 |
## 总结

| 头部          | 优势和特点                                                   | 劣势和问题                                                   |
| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| Expires       | 1、HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用，简单易用。 2、以时刻标识失效时间。 | 1、时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。 2、存在版本问题，到期之前的修改客户端是不可知的。 |
| Cache-Control | 1、HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。 2、比Expires多了很多选项设置。 | 1、HTTP 1.1 才有的内容，不适用于HTTP 1.0 。 2、存在版本问题，到期之前的修改客户端是不可知的。 |
| Last-Modified | 1、不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。 | 1、只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。 2、以时刻作为标识，无法识别一秒内进行多次修改的情况。 3、某些服务器不能精确的得到文件的最后修改时间。 |
| ETag          | 1、可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。 2、不存在版本问题，每次请求都回去服务器进行校验。 | 1、计算ETag值需要性能损耗。 2、分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时发现ETag不匹配的情况。 |